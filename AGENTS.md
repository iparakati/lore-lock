# Inform 7-Style Python Engine Architecture

This document outlines the architecture for the Python-based Interactive Fiction engine generated by `compiler.py`. The goal is to closely mimic the core functionality of the Inform 7 (I7) Standard Rules, specifically focusing on the Object Model, Action Processing, and World Model.

## 1. Core Architecture

The system consists of two parts:
1.  `src/compiler.py`: A compiler that reads a Story YAML file and generates a standalone Python script (the game) AND a companion test script.
2.  **The Game Runtime**: The generated Python code which contains the `World`, `Parser`, `Action` system, and `Rulebooks`.

## 2. Object Model (The "World")

The object hierarchy mimics I7. All game objects inherit from `Entity`.

### Class Hierarchy
*   `Entity` (Base class)
    *   `Room` (Locations)
    *   `Thing` (Physical objects)
        *   `Container` (Can contain things; openable, transparent/opaque)
        *   `Supporter` (Can support things on top)
        *   `Door` (Connects two rooms; lockable)
        *   `Person` (Alive; can carry things; supports conversation)
        *   `Wearable` (Clothing; can be worn)
        *   `Edible` (Food; can be eaten)

### Key Properties (Attributes)
All `Things` have a set of binary flags or properties:
*   `portable`, `lit`, `open`, `openable`, `locked`, `lockable`, `transparent`, `enterable`, `wearable`, `worn`, `edible`.

## 3. Action Processing System

The core of the engine replaces simple `if/else` checks with a Rulebook system.

### The Action Cycle
1.  **Before Rules**: Checks that happen *before* the action is attempted.
2.  **Check Rules**: Logical checks to see if the action is physically possible.
3.  **Carry Out Rules**: The state change happens here.
4.  **After Rules**: Reactions to the successful action.
5.  **Report Rules**: Standard feedback for the user.

### Meta-Commands
*   `undo`: Reverts the game state to the start of the previous turn.

## 4. Conversation System
*   **Verbs:** `ask`, `tell`.
*   **Logic:** `Person` entities have a `topics` dictionary mapping keywords to responses.

## 5. How to Add a Story

To add a new story or test case, create a new YAML file in `stories/yaml/`.

### Naming Convention
*   **File Name:** `story_<name>.yaml` (e.g., `story_mystery.yaml`).

### YAML Structure
The YAML file must include the following metadata to ensure the compiler can generate both the game and the test suite:

```yaml
title: "My Mystery Story"
purpose: "Demonstrate the conversation system and hidden doors." # Mandatory description of functionality

# The 'TEST ME' sequence.
# This list of commands is compiled into an automated test that validates the story.
test_sequence:
  - "look"
  - "ask detective about murder"
  - "north"
  - "examine bookshelf"
  - "pull book"

# The condition to pass the test
win_condition:
  type: "location"
  target: "Secret Lab"

# Game World Definition
scenes: ...
doors: ...
```

### Purpose of `test_sequence`
The `test_sequence` is crucial. It acts like Inform 7's `TEST ME` command.
*   **Synchronization:** The compiler uses this list to generate `stories/tests/test_<name>.py`. This ensures your test is always in sync with your story definition.
*   **Verification:** Running the test ensures that the sequence of commands is valid and leads to the `win_condition`.

### Compilation & Testing
After creating your file:

1.  **Compile:** `python src/compiler.py stories/yaml/story_mystery.yaml`
    *   This generates `stories/games/game_mystery.py` and `stories/tests/test_mystery.py`.
2.  **Test:** `python stories/tests/test_mystery.py`

To run the entire suite of stories:
```bash
python src/compiler.py --all
```

## 6. AI Integration
The `AIClient` remains a fallback. If the strict parser fails, the AI attempts to map the user's sentence to a strict command format.
