# Inform 7-Style Python Engine Architecture

This document outlines the architecture for the Python-based Interactive Fiction engine generated by `compiler.py`. The goal is to closely mimic the core functionality of the Inform 7 (I7) Standard Rules, specifically focusing on the Object Model, Action Processing, and World Model.

## 1. Core Architecture

The system consists of two parts:
1.  `compiler.py`: A compiler that reads a Story YAML file and generates a standalone Python script (the game).
2.  **The Game Runtime**: The generated Python code which contains the `World`, `Parser`, `Action` system, and `Rulebooks`.

## 2. Object Model (The "World")

The object hierarchy mimics I7. All game objects inherit from `Entity`.

### Class Hierarchy
*   `Entity` (Base class)
    *   `Room` (Locations)
    *   `Thing` (Physical objects)
        *   `Container` (Can contain things; openable, transparent/opaque)
        *   `Supporter` (Can support things on top)
        *   `Door` (Connects two rooms; lockable)
        *   `Person` (Alive; can carry things; supports conversation)
        *   `Wearable` (Clothing; can be worn)
        *   `Edible` (Food; can be eaten)

### Key Properties (Attributes)
All `Things` have a set of binary flags or properties:
*   `portable`: Can be picked up (default True for most Things, False for Scenery).
*   `lit`: Provides light.
*   `open`: Is the container/door open?
*   `openable`: Can it be opened?
*   `locked`: Is it locked?
*   `lockable`: Can it be locked?
*   `transparent`: Can you see inside when closed?
*   `enterable`: Can the player enter it (Vehicles)?
*   `wearable`: Can be worn.
*   `worn`: Is currently worn.
*   `edible`: Can be eaten.

## 3. Action Processing System

The core of the engine replaces simple `if/else` checks with a Rulebook system.

### The Action Cycle
When a command is parsed (e.g., "put the red box on the table"), an `Action` object is created. The action is processed through five stages:

1.  **Before Rules**: Checks that happen *before* the action is attempted. (e.g., "Instead of taking the cactus: say 'Ouch!'"). If a rule returns `True` (or "stop"), the action halts.
2.  **Check Rules**: Logical checks to see if the action is physically possible. (e.g., "Check taking: The noun must not be the player."). If a check fails, the action halts.
3.  **Carry Out Rules**: The state change happens here. (e.g., actually moving the object from the room to inventory). This stage produces no text.
4.  **After Rules**: Reactions to the successful action. (e.g., "After taking the idol: The trap activates!"). If an After rule handles the action, it can stop the Report stage.
5.  **Report Rules**: Standard feedback for the user. (e.g., "Taken.").

### Parsing
The parser handles:
*   **Simple:** `VERB NOUN` (e.g., "take sword")
*   **Complex:** `VERB NOUN PREP NOUN` (e.g., "put sword in sack", "unlock door with key")
*   **Conversation:** `ASK NOUN ABOUT TOPIC`, `TELL NOUN ABOUT TOPIC`.
*   **Disambiguation:** If multiple objects match (e.g., "red box", "blue box"), strict matching is enforced, or AI fallback is used.

## 4. Conversation System
*   **Verbs:** `ask`, `tell`.
*   **Logic:** `Person` entities have a `topics` dictionary mapping keywords to responses.

## 5. YAML Schema for Story Files

The YAML format is the source of truth.

```yaml
scenes:
  - id: "kitchen"
    name: "Kitchen"
    description: "A clean white kitchen."
    contents:
      - id: "apple"
        kind: "edible"
        name: "red apple"
        description: "Juicy."

      - id: "chest"
        kind: "container"
        properties: { openable: true, open: false, locked: true }
        key: "silver key" # Helper for lockable logic

      - id: "chef"
        kind: "person"
        name: "Chef"
        topics:
          "food": "I made this apple pie just for you."
          "key": "I think I dropped it in the garden."

interactions:
  - verb: "take"
    target: "apple"
    type: "before" # 'before', 'after', 'instead'
    condition: "not player.is_wearing('gloves')" # Python expression
    message: "You don't want to touch it with bare hands!"
```

## 6. Development Instructions

*   **Test-Driven:** Use the specified test YAML files to verify each subsystem (Containers, Supporters, Conversation) independently.
*   **AI Integration:** The `AIClient` remains a fallback. If the strict parser fails, the AI attempts to map the user's sentence to a strict command format (e.g., "place the sphere inside the bucket" -> "put sphere in bucket").
